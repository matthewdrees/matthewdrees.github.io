---
layout: post
title:  "PSP A Self-Improvement Process for Software Engineers"
category: book
---

![Book cover](/assets/psp-a-self-improvement-process-for-software-engineers.jpg)

I actually bought this book a decade ago. I recall doing the first project and measuring the PSP0 statistics and finding value in the process, then I let the book languish on the shelf since then. Time for another go.

Here's the link to the programming and report exercises: https://resources.sei.cmu.edu/library/asset-view.cfm?assetid=530425. In the zip file: Student Workbook/PSP Student Workbook.2006.10.07/PSP Course Materials/ASGKIT PROG*.doc. (The link in the book doesn't work anymore.)

### Key Takeaways
1. Introduces a personal development process. Asks the reader to write ~20 coding problems and record some metrics (time, # defects, etc.), then use those metrics for analysis for improvement or estimating.

### Preface
"The record of most development groups is poor, but the record of software groups is particularly bad." (p xiii). "If we are to call ourselves engineers, we must learn to produce quality products on predictable schedules" (p. xiv). The author compares the challenege of improving software skills to that of running faster, where you know your best running time, and find ways to improve on that time.

To learn the PSP, "write a program at each of the six PSP process levels plus an additional two to four programs to master the methods and build the data to support your continuning work" (p. xvii).

### 1. The Personal Process Strategy.
We need better better personal performance on a software team, like a musician in a symphony. Interestingly, the author wrote 72 programs before "getting the hang" of his own process. 

### 2. The Baseline Personal Process.
Do a small coding project using their introductory "PSP0" process. (Note above where these are found.) This lightweight process measures time and defects in 3 phases: planning, development, and postmortem.

The process asks you to do all your coding up front before compiling. I would normally put all the unit test code in place first, then compile, convince myself that a failing test behaves the way I want, and then code up the solution. I kept an open mind and did it all up front. In the future perhaps that will become 2 separate iterations of the process?
